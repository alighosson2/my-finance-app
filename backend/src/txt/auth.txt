import express, { Request, Response } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';
import cookieParser from 'cookie-parser';


const prisma = new PrismaClient();
const router = express.Router();
const JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret'; // Set this in .env

// Use cookie-parser middleware
router.use(cookieParser());

// POST /api/signup
router.post('/signup', async (req: Request, res: Response): Promise<void> => {
  const { name, email, password } = req.body as {
    name: string;
    email: string;
    password: string;
  };

  if (!name || !email || !password) {
    res.status(400).json({ error: 'All fields are required' });
    return;
  }

  const existing = await prisma.users.findUnique({ where: { email } });
  if (existing) {
    res.status(400).json({ error: 'Email already in use' });
    return;
  }

  const hash = await bcrypt.hash(password, 10);
  const user = await prisma.users.create({
    data: { name, email, password_hash: hash },
    select: { id: true, name: true, email: true, created_at: true },
  });

  const accessToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '15m' });
  const refreshToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });

  // Optionally, store refreshToken in DB for revocation purposes
  // await prisma.refreshToken.create({ data: { userId: user.id, token: refreshToken } });

  res
    .cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    })
    .status(201)
    .json({
      message: 'User created successfully',
      user: { id: user.id, name: user.name, email: user.email },
      accessToken,
    });
});

// POST /api/login
router.post('/login', async (req: Request, res: Response): Promise<void> => {
  const { email, password } = req.body as {
    email: string;
    password: string;
  };

  if (!email || !password) {
    res.status(400).json({ error: 'Email and password are required' });
    return;
  }

  const user = await prisma.users.findUnique({
    where: { email },
    select: { id: true, name: true, email: true, password_hash: true },
  });

  if (!user) {
    res.status(400).json({ error: 'Invalid credentials' });
    return;
  }

  const valid = await bcrypt.compare(password, user.password_hash);
  if (!valid) {
    res.status(400).json({ error: 'Invalid credentials' });
    return;
  }

  const accessToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '15m' });
  const refreshToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });

  // Optionally, store refreshToken in DB for revocation purposes
  // await prisma.refreshToken.create({ data: { userId: user.id, token: refreshToken } });

  res
    .cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    })
    .json({
      message: 'Login successful',
      user: { id: user.id, name: user.name, email: user.email },
      accessToken,
    });
});

// POST /api/refresh-token
router.post('/refresh-token', async (req: Request, res: Response): Promise<void> => {
  const token = req.cookies.refreshToken;
  if (!token) {
    res.status(401).json({ error: 'No refresh token provided' });
    return;
  }

  try {
    const payload = jwt.verify(token, JWT_SECRET) as { userId: number };
    const newAccessToken = jwt.sign({ userId: payload.userId }, JWT_SECRET, { expiresIn: '15m' });
    const newRefreshToken = jwt.sign({ userId: payload.userId }, JWT_SECRET, { expiresIn: '7d' });

    // Optionally, rotate refresh tokens in DB
    // await prisma.refreshToken.delete({ where: { token } });
    // await prisma.refreshToken.create({ data: { userId: payload.userId, token: newRefreshToken } });

    res
      .cookie('refreshToken', newRefreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      })
      .json({ accessToken: newAccessToken });
  } catch (err) {
    res.status(403).json({ error: 'Invalid or expired refresh token' });
  }
});

export default router;
